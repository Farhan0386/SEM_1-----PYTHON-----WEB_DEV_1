Numeric and Boolean Types - Beginner Summary
--------------------------------------------

This short summary explains the basic numeric and boolean types in Python with simple examples and common operations so you can start practicing right away.

1) Numeric types
   - int: integers (whole numbers), e.g., -3, 0, 42
	   * No separate type for long integers in Python 3 — integers can grow as large as memory allows.
	   * Operations: +, -, *, // (integer division), % (modulo), ** (power)

	   Examples:
	   a = 10
	   b = -3
	   print(a + b)   # 7
	   print(a // 3)  # 3 (integer division)
	   print(a % 3)   # 1 (remainder)

   - float: floating-point numbers (decimal), e.g., 3.14, -0.001
	   * Represent real numbers with limited precision (approx 15 decimal digits).
	   * Useful for measurements and calculations that require fractions.

	   Examples:
	   x = 2.5
	   y = 1.25
	   print(x * y)    # 3.125
	   print(x / 2)    # 1.25

   - complex: complex numbers with real and imaginary parts, e.g., 3+4j
	   * Written as a + bj where a is the real part and b is the imaginary coefficient.
	   * Useful in scientific and engineering calculations.

	   Examples:
	   z = 3 + 4j
	   print(z.real)   # 3.0
	   print(z.imag)   # 4.0

2) Boolean type
   - bool: represents truth values True and False (capitalized).
	   * Internally subclass of int: True == 1, False == 0 (but use as booleans).
	   * Results from comparisons and logical operations.

	   Examples:
	   t = True
	   f = False
	   print(3 > 2)     # True
	   print(t + 1)     # 2  (because True acts like 1)

   - Logical operators:
	   * and, or, not
	   * Short-circuit behavior: in `a and b`, `b` is evaluated only if `a` is True.

	   Examples:
	   print((3 > 2) and (1 == 1))   # True
	   print(not (2 > 5))            # True

3) Conversions
   - int(x), float(x), complex(x) convert between numeric types where possible.
   - bool(x) converts values to boolean: 0, 0.0, 0j, '', None, empty containers -> False; most others -> True.

	   Examples:
	   print(int(3.9))    # 3
	   print(float(2))    # 2.0
	   print(bool(0))     # False

4) Common pitfalls and tips
   - Floating point precision: don't expect exact equality with floats. Use a tolerance for comparisons.
	   * Example: abs(0.1 + 0.2 - 0.3) < 1e-9
   - Division behavior:
	   * `/` always returns a float (e.g., 5 / 2 -> 2.5)
	   * `//` performs floor division and returns an int for integer operands (5 // 2 -> 2)
   - Use `//` carefully with negative numbers (floor division rounds down).
   - When working with many numeric values or arrays, consider NumPy for better performance and numeric features.

5) Quick practice snippet
   Copy and run this in a Python REPL or a file named `practice_numeric.py`:

   a = 10
   b = 3
   print('a + b =', a + b)
   print('a / b =', a / b)
   print('a // b =', a // b)
   print('a % b =', a % b)

   x = 0.1 + 0.2
   print('0.1 + 0.2 == 0.3 ->', x == 0.3)
   print('difference =', x - 0.3)

   z = 1 + 2j
   print('z real:', z.real, 'imag:', z.imag)

   print('bool(0) ->', bool(0))
   print('bool([]) ->', bool([]))

6) Short glossary
   - integer (int): whole numbers
   - float: decimal numbers (limited precision)
   - complex: numbers with an imaginary part (a + bj)
   - bool: True or False

That's it — a compact beginner-friendly summary for numeric and boolean types. Practice the examples to get comfortable. If you want, I can also create a short `practice_numeric.py` file in this folder with the snippet.

